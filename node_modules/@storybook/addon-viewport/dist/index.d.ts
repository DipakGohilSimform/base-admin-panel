import { V as ViewportMap } from './Viewport-c277af0d.js';
import { ReactElement, ReactNode, WeakValidationMap, ValidationMap, FC, PropsWithChildren } from 'react';
import { L } from './main-c55d8855.js';

declare const ADDON_ID = "storybook/viewport";
declare const PARAM_KEY = "viewport";
declare const UPDATE = "storybook/viewport/update";
declare const CONFIGURE = "storybook/viewport/configure";
declare const SET = "storybook/viewport/setStoryDefaultViewport";
declare const CHANGED = "storybook/viewport/viewportChanged";

declare const INITIAL_VIEWPORTS: ViewportMap;
declare const DEFAULT_VIEWPORT = "responsive";
declare const MINIMAL_VIEWPORTS: ViewportMap;

declare global {
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

interface SBBaseType {
    required?: boolean;
    raw?: string;
}
type SBScalarType = SBBaseType & {
    name: 'boolean' | 'string' | 'number' | 'function' | 'symbol';
};
type SBArrayType = SBBaseType & {
    name: 'array';
    value: SBType;
};
type SBObjectType = SBBaseType & {
    name: 'object';
    value: Record<string, SBType>;
};
type SBEnumType = SBBaseType & {
    name: 'enum';
    value: (string | number)[];
};
type SBIntersectionType = SBBaseType & {
    name: 'intersection';
    value: SBType[];
};
type SBUnionType = SBBaseType & {
    name: 'union';
    value: SBType[];
};
type SBOtherType = SBBaseType & {
    name: 'other';
    value: string;
};
type SBType = SBScalarType | SBEnumType | SBArrayType | SBObjectType | SBIntersectionType | SBUnionType | SBOtherType;

type StoryId = string;
type ComponentId = string;
type ComponentTitle = string;
type StoryName = string;
/** @deprecated */
type StoryKind = ComponentTitle;
type Tag = string;
interface Parameters {
    [name: string]: any;
}
type ConditionalTest = {
    truthy?: boolean;
} | {
    exists: boolean;
} | {
    eq: any;
} | {
    neq: any;
};
type ConditionalValue = {
    arg: string;
} | {
    global: string;
};
type Conditional = ConditionalValue & ConditionalTest;
interface InputType {
    name?: string;
    description?: string;
    defaultValue?: any;
    type?: SBType | SBScalarType['name'];
    if?: Conditional;
    [key: string]: any;
}
interface Args {
    [name: string]: any;
}
type ArgTypes<TArgs = Args> = {
    [name in keyof TArgs]: InputType;
};
interface Globals {
    [name: string]: any;
}
interface GlobalTypes {
    [name: string]: InputType;
}

/**
 * A URL pathname, beginning with a /.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.pathname
 */
declare type Pathname = string;
/**
 * A URL search string, beginning with a ?.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.search
 */
declare type Search = string;
/**
 * A URL fragment identifier, beginning with a #.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.hash
 */
declare type Hash = string;
/**
 * A unique string associated with a location. May be used to safely store
 * and retrieve data in some other storage API, like `localStorage`.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.key
 */
declare type Key = string;
/**
 * The pathname, search, and hash values of a URL.
 */
interface Path$1 {
    /**
     * A URL pathname, beginning with a /.
     *
     * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.pathname
     */
    pathname: Pathname;
    /**
     * A URL search string, beginning with a ?.
     *
     * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.search
     */
    search: Search;
    /**
     * A URL fragment identifier, beginning with a #.
     *
     * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.hash
     */
    hash: Hash;
}
/**
 * An entry in a history stack. A location contains information about the
 * URL path, as well as possibly some arbitrary state and a key.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location
 */
interface Location extends Path$1 {
    /**
     * A value of arbitrary data associated with this location.
     *
     * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.state
     */
    state: unknown;
    /**
     * A unique string associated with this location. May be used to safely store
     * and retrieve data in some other storage API, like `localStorage`.
     *
     * Note: This value is always "default" on the initial location.
     *
     * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.key
     */
    key: Key;
}
/**
 * Describes a location that is the destination of some navigation, either via
 * `history.push` or `history.replace`. May be either a URL or the pieces of a
 * URL path.
 */
declare type To = string | Partial<Path$1>;

interface NavigateOptions$1$1 {
    replace?: boolean;
    state?: any;
}

interface StoryData {
    viewMode?: string;
    storyId?: string;
    refId?: string;
}

interface Other$1 extends StoryData {
    path: string;
    singleStory?: boolean;
}
type NavigateOptions$2 = NavigateOptions$1$1 & {
    plain?: boolean;
};
type NavigateFunction = (to: To | number, options?: NavigateOptions$2) => void;
type RouterData = {
    location: Partial<Location>;
    navigate: NavigateFunction;
} & Other$1;
type RenderData = Pick<RouterData, 'location'> & Other$1;

interface ThemeVars extends ThemeVarsBase, ThemeVarsColors {
}
interface ThemeVarsBase {
    base: 'light' | 'dark';
}
interface ThemeVarsColors {
    colorPrimary: string;
    colorSecondary: string;
    appBg: string;
    appContentBg: string;
    appPreviewBg: string;
    appBorderColor: string;
    appBorderRadius: number;
    fontBase: string;
    fontCode: string;
    textColor: string;
    textInverseColor: string;
    textMutedColor: string;
    barTextColor: string;
    barHoverColor: string;
    barSelectedColor: string;
    barBg: string;
    buttonBg: string;
    buttonBorder: string;
    booleanBg: string;
    booleanSelectedBg: string;
    inputBg: string;
    inputBorder: string;
    inputTextColor: string;
    inputBorderRadius: number;
    brandTitle?: string;
    brandUrl?: string;
    brandImage?: string;
    brandTarget?: string;
    gridCellSize?: number;
}

type ChannelHandler = (event: ChannelEvent) => void;
interface ChannelTransport {
    send(event: ChannelEvent, options?: any): void;
    setHandler(handler: ChannelHandler): void;
}
interface ChannelEvent {
    type: string;
    from: string;
    args: any[];
}
interface Listener {
    (...args: any[]): void;
}
interface ChannelArgsSingle {
    transport?: ChannelTransport;
    async?: boolean;
}
interface ChannelArgsMulti {
    transports: ChannelTransport[];
    async?: boolean;
}

declare class Channel {
    readonly isAsync: boolean;
    private sender;
    private events;
    private data;
    private readonly transports;
    constructor(input: ChannelArgsMulti);
    constructor(input: ChannelArgsSingle);
    get hasTransport(): boolean;
    addListener(eventName: string, listener: Listener): void;
    emit(eventName: string, ...args: any): void;
    last(eventName: string): any;
    eventNames(): string[];
    listenerCount(eventName: string): number;
    listeners(eventName: string): Listener[] | undefined;
    once(eventName: string, listener: Listener): void;
    removeAllListeners(eventName?: string): void;
    removeListener(eventName: string, listener: Listener): void;
    on(eventName: string, listener: Listener): void;
    off(eventName: string, listener: Listener): void;
    private handleEvent;
    private onceListener;
}
interface BaseIndexEntry {
    id: StoryId;
    name: StoryName;
    title: ComponentTitle;
    tags?: Tag[];
    importPath: Path;
}
type StoryIndexEntry = BaseIndexEntry & {
    type: 'story';
};
type DocsIndexEntry = BaseIndexEntry & {
    storiesImports: Path[];
    type: 'docs';
};
type IndexEntry = StoryIndexEntry | DocsIndexEntry;
interface StoryIndex {
    v: number;
    entries: Record<StoryId, IndexEntry>;
}

interface API_BaseEntry {
    id: StoryId;
    depth: number;
    name: string;
    refId?: string;
    renderLabel?: (item: API_BaseEntry) => any;
    /** @deprecated */
    isRoot: boolean;
    /** @deprecated */
    isComponent: boolean;
    /** @deprecated */
    isLeaf: boolean;
}
interface API_RootEntry extends API_BaseEntry {
    type: 'root';
    startCollapsed?: boolean;
    children: StoryId[];
    /** @deprecated */
    isRoot: true;
    /** @deprecated */
    isComponent: false;
    /** @deprecated */
    isLeaf: false;
}
interface API_GroupEntry extends API_BaseEntry {
    type: 'group';
    parent?: StoryId;
    children: StoryId[];
    /** @deprecated */
    isRoot: false;
    /** @deprecated */
    isComponent: false;
    /** @deprecated */
    isLeaf: false;
}
interface API_ComponentEntry extends API_BaseEntry {
    type: 'component';
    parent?: StoryId;
    children: StoryId[];
    /** @deprecated */
    isRoot: false;
    /** @deprecated */
    isComponent: true;
    /** @deprecated */
    isLeaf: false;
}
interface API_DocsEntry extends API_BaseEntry {
    type: 'docs';
    parent: StoryId;
    title: ComponentTitle;
    /** @deprecated */
    kind: ComponentTitle;
    importPath: Path;
    tags: Tag[];
    prepared: boolean;
    parameters?: {
        [parameterName: string]: any;
    };
    /** @deprecated */
    isRoot: false;
    /** @deprecated */
    isComponent: false;
    /** @deprecated */
    isLeaf: true;
}
interface API_StoryEntry extends API_BaseEntry {
    type: 'story';
    parent: StoryId;
    title: ComponentTitle;
    /** @deprecated */
    kind: ComponentTitle;
    importPath: Path;
    tags: Tag[];
    prepared: boolean;
    parameters?: {
        [parameterName: string]: any;
    };
    args?: Args;
    argTypes?: ArgTypes;
    initialArgs?: Args;
    /** @deprecated */
    isRoot: false;
    /** @deprecated */
    isComponent: false;
    /** @deprecated */
    isLeaf: true;
}
type API_LeafEntry = API_DocsEntry | API_StoryEntry;
type API_HashEntry = API_RootEntry | API_GroupEntry | API_ComponentEntry | API_DocsEntry | API_StoryEntry;
/**
 * The `IndexHash` is our manager-side representation of the `StoryIndex`.
 * We create entries in the hash not only for each story or docs entry, but
 * also for each "group" of the component (split on '/'), as that's how things
 * are manipulated in the manager (i.e. in the sidebar)
 */
interface API_IndexHash {
    [id: string]: API_HashEntry;
}
type API_PreparedIndexEntry = IndexEntry & {
    parameters?: Parameters;
    argTypes?: ArgTypes;
    args?: Args;
    initialArgs?: Args;
};
interface API_PreparedStoryIndex {
    v: number;
    entries: Record<StoryId, API_PreparedIndexEntry>;
}
interface API_Version {
    version: string;
    info?: {
        plain: string;
    };
    [key: string]: any;
}
type API_StatusValue = 'pending' | 'success' | 'error' | 'warn' | 'unknown';
interface API_StatusObject {
    status: API_StatusValue;
    title: string;
    description: string;
    data?: any;
}
type API_StatusState = Record<StoryId, Record<string, API_StatusObject>>;
type API_StatusUpdate = Record<StoryId, API_StatusObject | null>;
type API_FilterFunction = (item: API_PreparedIndexEntry & {
    status: Record<string, API_StatusObject | null>;
}) => boolean;

interface SetStoriesStory {
    id: StoryId;
    name: string;
    refId?: string;
    componentId?: ComponentId;
    kind: StoryKind;
    parameters: {
        fileName: string;
        options: {
            [optionName: string]: any;
        };
        docsOnly?: boolean;
        viewMode?: API_ViewMode;
        [parameterName: string]: any;
    };
    argTypes?: ArgTypes;
    args?: Args;
    initialArgs?: Args;
}
interface SetStoriesStoryData {
    [id: string]: SetStoriesStory;
}

type OrString$1<T extends string> = T | (string & {});
type API_ViewMode = OrString$1<'story' | 'docs' | 'settings'> | undefined;
/**
 * @deprecated This interface will be removed in 8.0
 */
type API_Panels = Addon_Collection<Addon_BaseType>;
type API_StateMerger<S> = (input: S) => S;
interface API_Provider<API> {
    channel?: Channel;
    /**
     * @deprecated will be removed in 8.0, please use channel instead
     */
    serverChannel?: Channel;
    renderPreview?: API_IframeRenderer;
    handleAPI(api: API): void;
    getConfig(): {
        sidebar?: API_SidebarOptions;
        theme?: ThemeVars;
        StoryMapper?: API_StoryMapper;
        [k: string]: any;
    } & Partial<API_UIOptions>;
    [key: string]: any;
}
type API_IframeRenderer = (storyId: string, viewMode: API_ViewMode, id: string, baseUrl: string, scale: number, queryParams: Record<string, any>) => ReactElement<any, any> | null;
interface API_UIOptions {
    name?: string;
    url?: string;
    goFullScreen: boolean;
    showStoriesPanel: boolean;
    showAddonPanel: boolean;
    addonPanelInRight: boolean;
    theme?: ThemeVars;
    selectedPanel?: string;
}
type API_PanelPositions = 'bottom' | 'right';
interface API_SidebarOptions {
    showRoots?: boolean;
    filters?: Record<string, API_FilterFunction>;
    collapsedRoots?: string[];
    renderLabel?: (item: API_HashEntry) => any;
}
interface OnClearOptions {
    /**
     *  True when the user dismissed the notification.
     */
    dismissed: boolean;
}
interface API_Notification {
    id: string;
    link: string;
    content: {
        headline: string;
        subHeadline?: string | any;
    };
    icon?: {
        name: string;
        color?: string;
    };
    onClear?: (options: OnClearOptions) => void;
}
type API_Versions = Record<string, string>;
type API_SetRefData = Partial<API_ComposedRef & {
    setStoriesData: SetStoriesStoryData;
    storyIndex: StoryIndex;
}>;
type API_StoryMapper = (ref: API_ComposedRef, story: SetStoriesStory) => SetStoriesStory;
interface API_LoadedRefData {
    index?: API_IndexHash;
    indexError?: Error;
    previewInitialized: boolean;
}
interface API_ComposedRef extends API_LoadedRefData {
    id: string;
    title?: string;
    url: string;
    type?: 'auto-inject' | 'unknown' | 'lazy' | 'server-checked';
    expanded?: boolean;
    versions?: API_Versions;
    loginUrl?: string;
    version?: string;
}
type API_ComposedRefUpdate = Partial<Pick<API_ComposedRef, 'title' | 'type' | 'expanded' | 'index' | 'versions' | 'loginUrl' | 'version' | 'indexError' | 'previewInitialized'>>;
type API_Refs = Record<string, API_ComposedRef>;

type Addon_Types = Exclude<Addon_TypesEnum, Addon_TypesEnum.experimental_PAGE | Addon_TypesEnum.experimental_SIDEBAR_BOTTOM | Addon_TypesEnum.experimental_SIDEBAR_TOP>;
interface Addon_RenderOptions {
    active: boolean;
    /**
     * @deprecated You should not use key anymore as of Storybook 7.2 this render method is invoked as a React component.
     * This property will be removed in 8.0.
     * */
    key?: unknown;
}
type Addon_Type = Addon_BaseType | Addon_PageType | Addon_WrapperType | Addon_SidebarBottomType | Addon_SidebarTopType;
interface Addon_BaseType {
    /**
     * The title of the addon.
     * This can be a simple string, but it can also be a React.FunctionComponent or a React.ReactElement.
     */
    title: FCWithoutChildren | ReactNode;
    /**
     * The type of the addon.
     * @example Addon_TypesEnum.PANEL
     */
    type: Exclude<Addon_Types, Addon_TypesEnum.PREVIEW | Addon_TypesEnum.experimental_PAGE | Addon_TypesEnum.experimental_SIDEBAR_BOTTOM | Addon_TypesEnum.experimental_SIDEBAR_TOP>;
    /**
     * The unique id of the addon.
     * @warn This will become non-optional in 8.0
     *
     * This needs to be globally unique, so we recommend prefixing it with your org name or npm package name.
     *
     * Do not prefix with `storybook`, this is reserved for core storybook feature and core addons.
     *
     * @example 'my-org-name/my-addon-name'
     */
    id?: string;
    /**
     * This component will wrap your `render` function.
     *
     * With it you can determine if you want your addon to be rendered or not.
     *
     * This is to facilitate addons keeping state, and keep listening for events even when they are not currently on screen/rendered.
     */
    route?: (routeOptions: RenderData) => string;
    /**
     * This will determine the value of `active` prop of your render function.
     */
    match?: (matchOptions: RenderData) => boolean;
    /**
     * The actual contents of your addon.
     *
     * This is called as a function, so if you want to use hooks,
     * your function needs to return a JSX.Element within which components are rendered
     */
    render: (renderOptions: Partial<Addon_RenderOptions>) => ReactElement<any, any> | null;
    /**
     * @unstable
     */
    paramKey?: string;
    /**
     * @unstable
     */
    disabled?: boolean;
    /**
     * @unstable
     */
    hidden?: boolean;
}
/**
 * This is a copy of FC from react/index.d.ts, but has the PropsWithChildren type removed
 * this is correct and more type strict, and future compatible with React.FC in React 18+
 *
 * @deprecated This type is deprecated and will be removed in 8.0. (assuming the manager uses React 18 is out by then)
 */
interface FCWithoutChildren<P = {}> {
    (props: P, context?: any): ReactElement<any, any> | null;
    propTypes?: WeakValidationMap<P> | undefined;
    contextTypes?: ValidationMap<any> | undefined;
    defaultProps?: Partial<P> | undefined;
    displayName?: string | undefined;
}
interface Addon_PageType {
    type: Addon_TypesEnum.experimental_PAGE;
    /**
     * The unique id of the page.
     */
    id: string;
    /**
     * The URL to navigate to when Storybook needs to navigate to this page.
     */
    url: string;
    /**
     * The title is used in mobile mode to represent the page in the navigation.
     */
    title: FCWithoutChildren | string | ReactElement | ReactNode;
    /**
     * The main content of the addon, a function component without any props.
     * Storybook will render your component always.
     *
     * If you want to render your component only when the URL matches, use the `Route` component.
     * @example
     * import { Route } from '@storybook/router';
     *
     * render: () => {
     *   return (
     *     <Route path="/my-addon">
     *       <MyAddonContent />
     *     </Route>
     *   );
     * };
     */
    render: FCWithoutChildren;
}
interface Addon_WrapperType {
    type: Addon_TypesEnum.PREVIEW;
    /**
     * The unique id of the page.
     */
    id: string;
    /**
     * A React.FunctionComponent that wraps the story.
     *
     * This component must accept a children prop, and render it.
     */
    render: FC<PropsWithChildren<{
        index: number;
        children: ReactNode;
        id: string;
        storyId: StoryId;
        active: boolean;
    }>>;
}
interface Addon_SidebarBottomType {
    type: Addon_TypesEnum.experimental_SIDEBAR_BOTTOM;
    /**
     * The unique id of the tool.
     */
    id: string;
    /**
     * A React.FunctionComponent.
     */
    render: FCWithoutChildren;
}
interface Addon_SidebarTopType {
    type: Addon_TypesEnum.experimental_SIDEBAR_TOP;
    /**
     * The unique id of the tool.
     */
    id: string;
    /**
     * A React.FunctionComponent.
     */
    render: FCWithoutChildren;
}
type Addon_TypeBaseNames = Exclude<Addon_TypesEnum, Addon_TypesEnum.PREVIEW | Addon_TypesEnum.experimental_PAGE | Addon_TypesEnum.experimental_SIDEBAR_BOTTOM | Addon_TypesEnum.experimental_SIDEBAR_TOP>;
interface Addon_TypesMapping extends Record<Addon_TypeBaseNames, Addon_BaseType> {
    [Addon_TypesEnum.PREVIEW]: Addon_WrapperType;
    [Addon_TypesEnum.experimental_PAGE]: Addon_PageType;
    [Addon_TypesEnum.experimental_SIDEBAR_BOTTOM]: Addon_SidebarBottomType;
    [Addon_TypesEnum.experimental_SIDEBAR_TOP]: Addon_SidebarTopType;
}
interface Addon_Collection<T = Addon_Type> {
    [key: string]: T;
}
declare enum Addon_TypesEnum {
    /**
     * This API is used to create a tab the toolbar above the canvas, This API might be removed in the future.
     * @unstable
     */
    TAB = "tab",
    /**
     * This adds panels to the addons side panel.
     */
    PANEL = "panel",
    /**
     * This adds items in the toolbar above the canvas - on the left side.
     */
    TOOL = "tool",
    /**
     * This adds items in the toolbar above the canvas - on the right side.
     */
    TOOLEXTRA = "toolextra",
    /**
     * This adds wrapper components around the canvas/iframe component storybook renders.
     * @unstable this API is not stable yet, and is likely to change in 8.0.
     */
    PREVIEW = "preview",
    /**
     * This adds pages that render instead of the canvas.
     * @unstable
     */
    experimental_PAGE = "page",
    /**
     * This adds items in the bottom of the sidebar.
     * @unstable
     */
    experimental_SIDEBAR_BOTTOM = "sidebar-bottom",
    /**
     * This adds items in the top of the sidebar.
     * @unstable This will get replaced with a new API in 8.0, use at your own risk.
     */
    experimental_SIDEBAR_TOP = "sidebar-top",
    /**
     * @deprecated This property does nothing, and will be removed in Storybook 8.0.
     */
    NOTES_ELEMENT = "notes-element"
}
type Path = string;

interface NavigateOptions$1 {
    replace?: boolean;
    state?: any;
}
type NavigateOptions = NavigateOptions$1 & {
    plain?: boolean;
};

declare global {
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

/**
 * Generate a storybook ID from a component/kind and story name.
 */
declare const toId: (kind: string, name?: string) => string;

interface Options {
    persistence: 'none' | 'session' | string;
}

interface SubAPI$c {
    renderPreview?: API_IframeRenderer;
}

interface SubAPI$b {
    /**
     * Returns a collection of elements of a specific type.
     * @protected This is used internally in storybook's manager.
     * @template T - The type of the elements in the collection.
     * @param {Addon_Types | Addon_TypesEnum.experimental_PAGE} type - The type of the elements to retrieve.
     * @returns {API_Collection<T>} - A collection of elements of the specified type.
     */
    getElements: <T extends Addon_Types | Addon_TypesEnum.experimental_PAGE | Addon_TypesEnum.experimental_SIDEBAR_BOTTOM | Addon_TypesEnum.experimental_SIDEBAR_TOP = Addon_Types>(type: T) => Addon_Collection<Addon_TypesMapping[T]>;
    /**
     * Returns a collection of all panels.
     * This is the same as calling getElements('panel')
     * @protected This is used internally in storybook's manager.
     * @deprecated please use getElements('panel') instead. This API will be removed in storybook 8.0.
     * @returns {API_Panels} - A collection of all panels.
     */
    getPanels: () => API_Panels;
    /**
     * Returns a collection of panels currently enabled for the selected story.
     * @protected This is used internally in storybook's manager.
     * @deprecated please use getElements('panel') instead, and do the filtering manually. This API will be removed in storybook 8.0.
     * @returns {API_Panels} - A collection of all panels.
     */
    getStoryPanels: () => API_Panels;
    /**
     * Returns the id of the currently selected panel.
     * @returns {string} - The ID of the currently selected panel.
     */
    getSelectedPanel: () => string;
    /**
     * Sets the currently selected panel via it's ID.
     * @param {string} panelName - The ID of the panel to select.
     * @returns {void}
     */
    setSelectedPanel: (panelName: string) => void;
    /**
     * Sets the state of an addon with the given ID.
     * @template S - The type of the addon state.
     * @param {string} addonId - The ID of the addon to set the state for.
     * @param {S | API_StateMerger<S>} newStateOrMerger - The new state to set, or a function which receives the current state and returns the new state.
     * @param {Options} [options] - Optional options for the state update.
     * @deprecated This API might get dropped, if you are using this, please file an issue.
     * @returns {Promise<S>} - A promise that resolves with the new state after it has been set.
     */
    setAddonState<S>(addonId: string, newStateOrMerger: S | API_StateMerger<S>, options?: Options): Promise<S>;
    /**
     * Returns the state of an addon with the given ID.
     * @template S - The type of the addon state.
     * @param {string} addonId - The ID of the addon to get the state for.
     * @deprecated This API might get dropped, if you are using this, please file an issue.
     * @returns {S} - The state of the addon with the given ID.
     */
    getAddonState<S>(addonId: string): S;
}

interface SubAPI$a {
    /**
     * Returns the channel object.
     * @protected Please do not use, it's for internal use only.
     */
    getChannel: () => API_Provider<API>['channel'];
    /**
     * Adds a listener to the channel for the given event type.
     * Returns a function that can be called to remove the listener.
     * @param type - The event type to listen for. If using a core event, import it from `@storybook/core-events`.
     * @param handler - The callback function to be called when the event is emitted.
     * @returns A function that can be called to remove the listener.
     */
    on: (type: string, handler: L) => () => void;
    /**
     * Removes a listener from the channel for the given event type.
     * @param type - The event type to remove the listener from. If using a core event, import it from `@storybook/core-events`.
     * @param handler - The callback function to be removed.
     */
    off: (type: string, handler: L) => void;
    /**
     * Emits an event on the channel for the given event type.
     * @param type - The event type to emit. If using a core event, import it from `@storybook/core-events`.
     * @param args - The arguments to pass to the event listener.
     */
    emit: (type: string, ...args: any[]) => void;
    /**
     * Adds a one-time listener to the channel for the given event type.
     * @param type - The event type to listen for. If using a core event, import it from `@storybook/core-events`.
     * @param handler - The callback function to be called when the event is emitted.
     */
    once: (type: string, handler: L) => void;
    /**
     * Emits an event to collapse all stories in the UI.
     * @deprecated Use `emit(STORIES_COLLAPSE_ALL)` instead. This API will be removed in Storybook 8.0.
     */
    collapseAll: () => void;
    /**
     * Emits an event to expand all stories in the UI.
     * @deprecated Use `emit(STORIES_EXPAND_ALL)` instead. This API will be removed in Storybook 8.0.
     */
    expandAll: () => void;
}
/**
 * The API for managing notifications.
 */
interface SubAPI$9 {
    /**
     * Adds a new notification to the list of notifications.
     * If a notification with the same ID already exists, it will be replaced.
     * @param notification - The notification to add.
     */
    addNotification: (notification: API_Notification) => void;
    /**
     * Removes a notification from the list of notifications and calls the onClear callback.
     * @param id - The ID of the notification to remove.
     */
    clearNotification: (id: string) => void;
}

interface SubAPI$8 {
    storeSelection: () => void;
    retrieveSelection: () => StoryId;
    /**
     * Changes the active settings tab.
     * @param path - The path of the settings page to navigate to. The path NOT should include the `/settings` prefix.
     * @example  changeSettingsTab(`about`).
     */
    changeSettingsTab: (path: string) => void;
    /**
     * Closes the settings screen and returns to the last tracked story or the first story.
     */
    closeSettings: () => void;
    /**
     * Checks if the settings screen is currently active.
     * @returns A boolean indicating whether the settings screen is active.
     */
    isSettingsScreenActive: () => boolean;
    /**
     * Navigates to the specified settings page.
     * @param path - The path of the settings page to navigate to. The path should include the `/settings` prefix.
     * @example  navigateToSettingsPage(`/settings/about`).
     * @deprecated Use `changeSettingsTab` instead.
     */
    navigateToSettingsPage: (path: string) => Promise<void>;
}

type Direction = -1 | 1;
type ParameterName = string;
type StoryUpdate = Partial<Pick<API_StoryEntry, 'prepared' | 'parameters' | 'initialArgs' | 'argTypes' | 'args'>>;
type DocsUpdate = Partial<Pick<API_DocsEntry, 'prepared' | 'parameters'>>;
interface SubAPI$7 {
    /**
     * The `storyId` method is a reference to the `toId` function from `@storybook/csf`, which is used to generate a unique ID for a story.
     * This ID is used to identify a specific story in the Storybook index.
     *
     * @type {typeof toId}
     */
    storyId: typeof toId;
    /**
     * Resolves a story, docs, component or group ID to its corresponding hash entry in the index.
     *
     * @param {StoryId} storyId - The ID of the story to resolve.
     * @param {string} [refsId] - The ID of the refs to use for resolving the story.
     * @returns {API_HashEntry} - The hash entry corresponding to the given story ID.
     */
    resolveStory: (storyId: StoryId, refsId?: string) => API_HashEntry;
    /**
     * Selects the first story to display in the Storybook UI.
     *
     * @returns {void}
     */
    selectFirstStory: () => void;
    /**
     * Selects a story to display in the Storybook UI.
     *
     * @param {string} [kindOrId] - The kind or ID of the story to select.
     * @param {StoryId} [story] - The ID of the story to select.
     * @param {Object} [obj] - An optional object containing additional options.
     * @param {string} [obj.ref] - The ref ID of the story to select.
     * @param {API_ViewMode} [obj.viewMode] - The view mode to display the story in.
     * @returns {void}
     */
    selectStory: (kindOrId?: string, story?: StoryId, obj?: {
        ref?: string;
        viewMode?: API_ViewMode;
    }) => void;
    /**
     * Returns the current story's data, including its ID, kind, name, and parameters.
     *
     * @returns {API_LeafEntry} The current story's data.
     */
    getCurrentStoryData: () => API_LeafEntry;
    /**
     * Sets the prepared story index to the given value.
     *
     * @param {API_PreparedStoryIndex} index - The prepared story index to set.
     * @returns {Promise<void>} A promise that resolves when the prepared story index has been set.
     */
    setIndex: (index: API_PreparedStoryIndex) => Promise<void>;
    /**
     * Jumps to the next or previous component in the index.
     *
     * @param {Direction} direction - The direction to jump. Use -1 to jump to the previous component, and 1 to jump to the next component.
     * @returns {void}
     */
    jumpToComponent: (direction: Direction) => void;
    /**
     * Jumps to the next or previous story in the story index.
     *
     * @param {Direction} direction - The direction to jump. Use -1 to jump to the previous story, and 1 to jump to the next story.
     * @returns {void}
     */
    jumpToStory: (direction: Direction) => void;
    /**
     * Returns the data for the given story ID and optional ref ID.
     *
     * @param {StoryId} storyId - The ID of the story to retrieve data for.
     * @param {string} [refId] - The ID of the ref to retrieve data for. If not provided, retrieves data for the default ref.
     * @returns {API_LeafEntry} The data for the given story ID and optional ref ID.
     */
    getData: (storyId: StoryId, refId?: string) => API_LeafEntry;
    /**
     * Returns a boolean indicating whether the given story ID and optional ref ID have been prepared.
     *
     * @param {StoryId} storyId - The ID of the story to check.
     * @param {string} [refId] - The ID of the ref to check. If not provided, checks all refs for the given story ID.
     * @returns {boolean} A boolean indicating whether the given story ID and optional ref ID have been prepared.
     */
    isPrepared: (storyId: StoryId, refId?: string) => boolean;
    /**
     * Returns the parameters for the given story ID and optional ref ID.
     *
     * @param {StoryId | { storyId: StoryId; refId: string }} storyId - The ID of the story to retrieve parameters for, or an object containing the story ID and ref ID.
     * @param {ParameterName} [parameterName] - The name of the parameter to retrieve. If not provided, returns all parameters.
     * @returns {API_StoryEntry['parameters'] | any} The parameters for the given story ID and optional ref ID.
     */
    getParameters: (storyId: StoryId | {
        storyId: StoryId;
        refId: string;
    }, parameterName?: ParameterName) => API_StoryEntry['parameters'] | any;
    /**
     * Returns the current value of the specified parameter for the currently selected story.
     *
     * @template S - The type of the parameter value.
     * @param {ParameterName} [parameterName] - The name of the parameter to retrieve. If not provided, returns all parameters.
     * @returns {S} The value of the specified parameter for the currently selected story.
     */
    getCurrentParameter<S>(parameterName?: ParameterName): S;
    /**
     * Updates the arguments for the given story with the provided new arguments.
     *
     * @param {API_StoryEntry} story - The story to update the arguments for.
     * @param {Args} newArgs - The new arguments to set for the story.
     * @returns {void}
     */
    updateStoryArgs(story: API_StoryEntry, newArgs: Args): void;
    /**
     * Resets the arguments for the given story to their initial values.
     *
     * @param {API_StoryEntry} story - The story to reset the arguments for.
     * @param {string[]} [argNames] - An optional array of argument names to reset. If not provided, all arguments will be reset.
     * @returns {void}
     */
    resetStoryArgs: (story: API_StoryEntry, argNames?: string[]) => void;
    /**
     * Finds the leaf entry for the given story ID in the given story index.
     *
     * @param {API_IndexHash} index - The story index to search for the leaf entry in.
     * @param {StoryId} storyId - The ID of the story to find the leaf entry for.
     * @returns {API_LeafEntry} The leaf entry for the given story ID, or null if no leaf entry was found.
     */
    findLeafEntry(index: API_IndexHash, storyId: StoryId): API_LeafEntry;
    /**
     * Finds the leaf story ID for the given component or group ID in the given index.
     *
     * @param {API_IndexHash} index - The story index to search for the leaf story ID in.
     * @param {StoryId} storyId - The ID of the story to find the leaf story ID for.
     * @returns {StoryId} The ID of the leaf story, or null if no leaf story was found.
     */
    findLeafStoryId(index: API_IndexHash, storyId: StoryId): StoryId;
    /**
     * Finds the ID of the sibling story in the given direction for the given story ID in the given story index.
     *
     * @param {StoryId} storyId - The ID of the story to find the sibling of.
     * @param {API_IndexHash} index - The story index to search for the sibling in.
     * @param {Direction} direction - The direction to search for the sibling in.
     * @param {boolean} toSiblingGroup - When true, skips over leafs within the same group.
     * @returns {StoryId} The ID of the sibling story, or null if no sibling was found.
     */
    findSiblingStoryId(storyId: StoryId, index: API_IndexHash, direction: Direction, toSiblingGroup: boolean): StoryId;
    /**
     * Fetches the story index from the server.
     *
     * @returns {Promise<void>} A promise that resolves when the index has been fetched.
     */
    fetchIndex: () => Promise<void>;
    /**
     * Updates the story with the given ID with the provided update object.
     *
     * @param {StoryId} storyId - The ID of the story to update.
     * @param {StoryUpdate} update - An object containing the updated story information.
     * @param {API_ComposedRef} [ref] - The composed ref of the story to update.
     * @returns {Promise<void>} A promise that resolves when the story has been updated.
     */
    updateStory: (storyId: StoryId, update: StoryUpdate, ref?: API_ComposedRef) => Promise<void>;
    /**
     * Updates the documentation for the given story ID with the given update object.
     *
     * @param {StoryId} storyId - The ID of the story to update.
     * @param {DocsUpdate} update - An object containing the updated documentation information.
     * @param {API_ComposedRef} [ref] - The composed ref of the story to update.
     * @returns {Promise<void>} A promise that resolves when the documentation has been updated.
     */
    updateDocs: (storyId: StoryId, update: DocsUpdate, ref?: API_ComposedRef) => Promise<void>;
    /**
     * Sets the preview as initialized.
     *
     * @param {ComposedRef} [ref] - The composed ref of the story to set as initialized.
     * @returns {Promise<void>} A promise that resolves when the preview has been set as initialized.
     */
    setPreviewInitialized: (ref?: API_ComposedRef) => Promise<void>;
    /**
     * Updates the status of a collection of stories.
     *
     * @param {string} addonId - The ID of the addon to update.
     * @param {StatusUpdate} update - An object containing the updated status information.
     * @returns {Promise<void>} A promise that resolves when the status has been updated.
     */
    experimental_updateStatus: (addonId: string, update: API_StatusUpdate | ((state: API_StatusState) => API_StatusUpdate)) => Promise<void>;
    /**
     * Updates the filtering of the index.
     *
     * @param {string} addonId - The ID of the addon to update.
     * @param {API_FilterFunction} filterFunction - A function that returns a boolean based on the story, index and status.
     * @returns {Promise<void>} A promise that resolves when the state has been updated.
     */
    experimental_setFilter: (addonId: string, filterFunction: API_FilterFunction) => Promise<void>;
}
interface SubAPI$6 {
    /**
     * Finds a composed ref by its source.
     * @param {string} source - The source/URL of the composed ref.
     * @returns {API_ComposedRef} - The composed ref object.
     */
    findRef: (source: string) => API_ComposedRef;
    /**
     * Sets a composed ref by its ID and data.
     * @param {string} id - The ID of the composed ref.
     * @param {API_SetRefData} data - The data to set for the composed ref.
     * @param {boolean} [ready] - Whether the composed ref is ready.
     */
    setRef: (id: string, data: API_SetRefData, ready?: boolean) => void;
    /**
     * Updates a composed ref by its ID and update object.
     * @param {string} id - The ID of the composed ref.
     * @param {API_ComposedRefUpdate} ref - The update object for the composed ref.
     */
    updateRef: (id: string, ref: API_ComposedRefUpdate) => void;
    /**
     * Gets all composed refs.
     * @returns {API_Refs} - The composed refs object.
     */
    getRefs: () => API_Refs;
    /**
     * Checks if a composed ref is valid.
     * @param {API_SetRefData} ref - The composed ref to check.
     * @returns {Promise<void>} - A promise that resolves when the check is complete.
     */
    checkRef: (ref: API_SetRefData) => Promise<void>;
    /**
     * Changes the version of a composed ref by its ID and URL.
     * @param {string} id - The ID of the composed ref.
     * @param {string} url - The new URL for the composed ref.
     */
    changeRefVersion: (id: string, url: string) => void;
    /**
     * Changes the state of a composed ref by its ID and previewInitialized flag.
     * @param {string} id - The ID of the composed ref.
     * @param {boolean} previewInitialized - The new previewInitialized flag for the composed ref.
     */
    changeRefState: (id: string, previewInitialized: boolean) => void;
}
interface SubAPI$5 {
    /**
     * Toggles the fullscreen mode of the Storybook UI.
     * @param toggled - Optional boolean value to set the fullscreen mode to. If not provided, it will toggle the current state.
     */
    toggleFullscreen: (toggled?: boolean) => void;
    /**
     * Toggles the visibility of the panel in the Storybook UI.
     * @param toggled - Optional boolean value to set the panel visibility to. If not provided, it will toggle the current state.
     */
    togglePanel: (toggled?: boolean) => void;
    /**
     * Toggles the position of the panel in the Storybook UI.
     * @param position - Optional string value to set the panel position to. If not provided, it will toggle between 'bottom' and 'right'.
     */
    togglePanelPosition: (position?: API_PanelPositions) => void;
    /**
     * Toggles the visibility of the navigation bar in the Storybook UI.
     * @param toggled - Optional boolean value to set the navigation bar visibility to. If not provided, it will toggle the current state.
     */
    toggleNav: (toggled?: boolean) => void;
    /**
     * Toggles the visibility of the toolbar in the Storybook UI.
     * @param toggled - Optional boolean value to set the toolbar visibility to. If not provided, it will toggle the current state.
     */
    toggleToolbar: (toggled?: boolean) => void;
    /**
     * Sets the options for the Storybook UI.
     * @param options - An object containing the options to set.
     */
    setOptions: (options: any) => void;
}
type KeyboardEventLike = Pick<KeyboardEvent, 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey' | 'key' | 'code' | 'keyCode' | 'preventDefault'>;
interface SubAPI$4 {
    /**
     * Returns the current shortcuts.
     */
    getShortcutKeys(): API_Shortcuts;
    /**
     * Returns the default shortcuts.
     */
    getDefaultShortcuts(): API_Shortcuts | API_AddonShortcutDefaults;
    /**
     * Returns the shortcuts for addons.
     */
    getAddonsShortcuts(): API_AddonShortcuts;
    /**
     * Returns the labels for addon shortcuts.
     */
    getAddonsShortcutLabels(): API_AddonShortcutLabels;
    /**
     * Returns the default shortcuts for addons.
     */
    getAddonsShortcutDefaults(): API_AddonShortcutDefaults;
    /**
     * Sets the shortcuts to the given value.
     * @param shortcuts The new shortcuts to set.
     * @returns A promise that resolves to the new shortcuts.
     */
    setShortcuts(shortcuts: API_Shortcuts): Promise<API_Shortcuts>;
    /**
     * Sets the shortcut for the given action to the given value.
     * @param action The action to set the shortcut for.
     * @param value The new shortcut to set.
     * @returns A promise that resolves to the new shortcut.
     */
    setShortcut(action: API_Action, value: API_KeyCollection): Promise<API_KeyCollection>;
    /**
     * Sets the shortcut for the given addon to the given value.
     * @param addon The addon to set the shortcut for.
     * @param shortcut The new shortcut to set.
     * @returns A promise that resolves to the new addon shortcut.
     */
    setAddonShortcut(addon: string, shortcut: API_AddonShortcut): Promise<API_AddonShortcut>;
    /**
     * Restores all default shortcuts.
     * @returns A promise that resolves to the new shortcuts.
     */
    restoreAllDefaultShortcuts(): Promise<API_Shortcuts>;
    /**
     * Restores the default shortcut for the given action.
     * @param action The action to restore the default shortcut for.
     * @returns A promise that resolves to the new shortcut.
     */
    restoreDefaultShortcut(action: API_Action): Promise<API_KeyCollection>;
    /**
     * Handles a keydown event.
     * @param event The event to handle.
     */
    handleKeydownEvent(event: KeyboardEventLike): void;
    /**
     * Handles a shortcut feature.
     * @param feature The feature to handle.
     * @param event The event to handle.
     */
    handleShortcutFeature(feature: API_Action, event: KeyboardEventLike): void;
}
type API_KeyCollection = string[];
interface API_Shortcuts {
    fullScreen: API_KeyCollection;
    togglePanel: API_KeyCollection;
    panelPosition: API_KeyCollection;
    toggleNav: API_KeyCollection;
    toolbar: API_KeyCollection;
    search: API_KeyCollection;
    focusNav: API_KeyCollection;
    focusIframe: API_KeyCollection;
    focusPanel: API_KeyCollection;
    prevComponent: API_KeyCollection;
    nextComponent: API_KeyCollection;
    prevStory: API_KeyCollection;
    nextStory: API_KeyCollection;
    shortcutsPage: API_KeyCollection;
    aboutPage: API_KeyCollection;
    escape: API_KeyCollection;
    collapseAll: API_KeyCollection;
    expandAll: API_KeyCollection;
    remount: API_KeyCollection;
}
type API_Action = keyof API_Shortcuts;
interface API_AddonShortcut {
    label: string;
    defaultShortcut: API_KeyCollection;
    actionName: string;
    showInMenu?: boolean;
    action: (...args: any[]) => any;
}
type API_AddonShortcuts = Record<string, API_AddonShortcut>;
type API_AddonShortcutLabels = Record<string, string>;
type API_AddonShortcutDefaults = Record<string, API_KeyCollection>;
interface QueryParams {
    [key: string]: string | null;
}
/**
 * SubAPI for managing URL navigation and state.
 */
interface SubAPI$3 {
    /**
     * Navigate to a new URL.
     * @param {string} url - The URL to navigate to.
     * @param {NavigateOptions} options - Options for the navigation.
     * @returns {void}
     */
    navigateUrl: (url: string, options: NavigateOptions) => void;
    /**
     * Get the value of a query parameter from the current URL.
     * @param {string} key - The key of the query parameter to get.
     * @returns {string | undefined} The value of the query parameter, or undefined if it does not exist.
     */
    getQueryParam: (key: string) => string | undefined;
    /**
     * Returns an object containing the current state of the URL.
     * @returns {{
     *   queryParams: QueryParams,
     *   path: string,
     *   viewMode?: string,
     *   storyId?: string,
     *   url: string
     * }} An object containing the current state of the URL.
     */
    getUrlState: () => {
        queryParams: QueryParams;
        path: string;
        viewMode?: string;
        storyId?: string;
        url: string;
    };
    /**
     * Set the query parameters for the current URL.
     * @param {QueryParams} input - An object containing the query parameters to set.
     * @returns {void}
     */
    setQueryParams: (input: QueryParams) => void;
}
interface SubAPI$2 {
    /**
     * Returns the current version of the Storybook Manager.
     *
     * @returns {API_Version} The current version of the Storybook Manager.
     */
    getCurrentVersion: () => API_Version;
    /**
     * Returns the latest version of the Storybook Manager.
     *
     * @returns {API_Version} The latest version of the Storybook Manager.
     */
    getLatestVersion: () => API_Version;
    /**
     * Checks if an update is available for the Storybook Manager.
     *
     * @returns {boolean} True if an update is available, false otherwise.
     */
    versionUpdateAvailable: () => boolean;
}
type SubAPI$1 = {
    isWhatsNewUnread(): boolean;
    whatsNewHasBeenRead(): void;
    toggleWhatsNewNotifications(): void;
};
interface SubAPI {
    /**
     * Returns the current global data object.
     * @returns {Globals} The current global data object.
     */
    getGlobals: () => Globals;
    /**
     * Returns the current global types object.
     * @returns {GlobalTypes} The current global types object.
     */
    getGlobalTypes: () => GlobalTypes;
    /**
     * Updates the current global data object with the provided new global data object.
     * @param {Globals} newGlobals - The new global data object to update with.
     * @returns {void}
     */
    updateGlobals: (newGlobals: Globals) => void;
}
type API = SubAPI$b & SubAPI$a & SubAPI$c & SubAPI$7 & SubAPI$6 & SubAPI & SubAPI$5 & SubAPI$9 & SubAPI$4 & SubAPI$8 & SubAPI$2 & SubAPI$3 & SubAPI$1 & Other;
interface Other {
    [key: string]: any;
}

declare const registerShortcuts: (api: API, setState: any, viewportsKeys: string[]) => Promise<void>;

export { ADDON_ID, CHANGED, CONFIGURE, DEFAULT_VIEWPORT, INITIAL_VIEWPORTS, MINIMAL_VIEWPORTS, PARAM_KEY, SET, UPDATE, registerShortcuts };
